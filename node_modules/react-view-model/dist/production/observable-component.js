/*react-view-model@2.0.0-pre.9#observable-component*/
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.default = undefined;
var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ('value' in descriptor)
                descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    return function (Constructor, protoProps, staticProps) {
        if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
            defineProperties(Constructor, staticProps);
        return Constructor;
    };
}();
var _react = require('react');
var _canReflect = require('can-reflect');
var _canReflect2 = _interopRequireDefault(_canReflect);
var _observer = require('./observer.js');
var _observer2 = _interopRequireDefault(_observer);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
    }
}
function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called');
    }
    return call && (typeof call === 'object' || typeof call === 'function') ? call : self;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== 'function' && superClass !== null) {
        throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var ObservableComponent = function (_Component) {
    _inherits(ObservableComponent, _Component);
    function ObservableComponent(props) {
        _classCallCheck(this, ObservableComponent);
        var _this = _possibleConstructorReturn(this, (ObservableComponent.__proto__ || Object.getPrototypeOf(ObservableComponent)).call(this, props));
        if (_this.constructor.prototype.hasOwnProperty('shouldComponentUpdate')) {
            _this.constructor.prototype._shouldComponentUpdate = _this.constructor.prototype.shouldComponentUpdate;
            delete _this.constructor.prototype.shouldComponentUpdate;
        }
        var observer = function () {
            if (typeof this._shouldComponentUpdate !== 'function' || this._shouldComponentUpdate()) {
                this.forceUpdate();
            }
        }.bind(_this);
        Object.defineProperty(observer, 'name', { value: _canReflect2.default.getName(_this) });
        Object.defineProperty(_this, '_observer', {
            writable: false,
            enumerable: false,
            configurable: false,
            value: new _observer2.default(observer)
        });
        return _this;
    }
    _createClass(ObservableComponent, [
        {
            key: 'shouldComponentUpdate',
            value: function shouldComponentUpdate() {
                return false;
            }
        },
        {
            key: 'componentWillMount',
            value: function componentWillMount() {
                this._observer.startRecording();
            }
        },
        {
            key: 'componentDidMount',
            value: function componentDidMount() {
                this._observer.stopRecording();
            }
        },
        {
            key: 'componentWillUpdate',
            value: function componentWillUpdate() {
                this._observer.startRecording();
            }
        },
        {
            key: 'componentDidUpdate',
            value: function componentDidUpdate() {
                this._observer.stopRecording();
            }
        },
        {
            key: 'componentWillUnmount',
            value: function componentWillUnmount() {
                this._observer.teardown();
            }
        }
    ]);
    return ObservableComponent;
}(_react.Component);
exports.default = ObservableComponent;